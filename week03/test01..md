1. 大家通常把 javascript 归类为一种“动态”或“解释执行”的语言，但事实上，它是一门编译语言，但和传统的编译语言不同，它不是提前编译的，编译结果也不能进行移植。

  + 分词/词法分析
  + 这个过程会把字符串分解成有意义的代码块，这些代码块被称为词法单元。
    例如 var a = 5; 这段程序通常会被分解成下面这些词法单元： var、a、=、5、; 。空格是否会被当成词法单元取决于空格在这门语言中是否有意义。
  + 解析/语法分析
  + 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。
    var a = 5; 的抽象语法树中可能如下图所示
  + 代码生成
  + 比起那些编译过程只有三个步骤的语言的编译器来说，javascript 引擎要复杂的多。
    例如，在词法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

    首先我们要清楚，javaScript 引擎不会有太多的时间来进行优化（相对于其它语言的编译器来说），因为与其它语言不同，javascript 的编译过程不是发生在构建之前的。

    对于 javascript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。在我们将要讨论的作用域背后，javascript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至重新编译）来保证性能最佳。

    总结来说，任何 javascript 代码片段在执行前都要进行编译（预编译）。因此，javascript 编译器首先会对 var a = 5; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。
  + 总结来说，变量的赋值会执行两个操作，首先编译器会在当前作用域声明一个变量（如果之前没有声明过），然后在运行时引擎会在当前作用域中查找该变量（找不到就向上一级作用域查找），如果能够找到就会对它赋值。
  + LHS RHS
  + 赋值操作的目标是谁（LHS）
  + “谁是赋值操作的源头（RHS）”
  + 10   ｜小测验检验一下到目前的理解程度。把自己当作引擎，并同作用域进行一次“对话”：function foo(a) {var b = a;return a + b;}var c = foo( 2 );
     1. 找到其中所有的LHS查询。（这里有3处！）
     + LHS var c=foo(2)  a=2  b=a    
     2. 找到其中所有的RHS查询。（这里有4处！）
      + foo(2)   =a   return a..  ..b
  +  作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。
  +  ~~~
        var b=5
        function foo(str,a){
            a=15
            eval(str)
            console.log(b+a)
        }
        foo('var b=10',2) // 25
    ~~~ 
 +   在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域 