+ FTP 协议：文件传输FTP还有助于访问服务器的物理位置，以修改文件，例如删除文件，创建文件夹甚至修改文件内容
 + 主动FTP 提高服务器的安全性能
 + 被动FTP 好处客户端的配置修改比较少
+ 端口与进程
  + 进程在进算计内部通信要标识唯一的进程，使用pid进行本地标识，两台计算机pid无法标识，使用端口号进行标识 字节序列为 主机ip+协议名+端口号标识网络中的一个进程 
+ 熟知端口号 http:80 https:443 smtp:25 ftp:21 tftp:69 telnet:23 snmp:161  dns:53  ：0-1023
+ 登记端口号 1024-49151
+ 客户端使用的端口号
  + 49152~65535
+ 报文首部结构
  + 源端口  目的端口：各站两个字节，发送方和接收方
   + 序列号  传输文件的每个字节都要编号，
  + 确认号 确认收到的总序列号
  + 数据偏移 保温数据序列号距离报文序列的距离
  + 保留 保留为今后所用，目前置为0
  + 标志位 共六位，每位各占一字节，0或者1，
    + 紧急URG =1 紧急指针有效 
    + 确认ACK ：确认报文段，确认号有效
    + 推送PSH ：该段优先级高
    + 复位RST ：连接出现严重错误，进行重连
    + 同步SYN ：请求连接报文
    + 终止FIN ：传输完成，断开连接
  + 窗口大小 指还允许发送方发送的数据量大小
  + 检验 占两个字节，对报文数据段和首部进行检查，执行CRC算法，这也是tcp安全可靠性的保证
  + 紧急指针 ：指向紧急数据的末尾，在此处插入一段紧急数据 
+  连接过程
   + 三次握手
     + 客户端发出TCP请求，状态转为SYN_SEND,状态位SYN=1,初始化一个序列号Squence Number=j
     + 服务端状态转为SYN-RCVD,如果同意链接 ACK=1 SYN=1,初始化一个序列号quence Number=k 确认号Acknowledgemt Number =j+1
     + 客户端接收到服务端报文，状态转为ESTABLISHED,此时SYN不再置为1，服务器接收到该报文状态也转为ESTABLISHED,ACK=1,确认号=k+1,序号=j+1
   + 四次挥手
     + 第一次挥手 ；客户端向服务端发送结束报文，FIN=1,状态位FIN_WAIT_1,序列号m
     + 第二次挥手 :服务端接收到结束报文,然后发送确认报文段，进入CLOSE_WAIT 状态 此时ACK=1 序列号为m+_1
     + 第三次挥手：服务端发结束报文，FIN=1,序列号为N  进入LAST_ACK 状态
     + 第四次挥手 ：客户端 序列号为N+1,发送确认报文段，进入TIME_WAIT状态，2msl之后自 动进入CLOSED状态 服务端接收到进入CLOSED状态
     + 2MSL 2个保温最长寿命    
+ TCP 流转图
  +CLOSED：表示初始状态

   + LISTEN：表示服务器端的某个 socket 处于监听状态，可以接受连接
   + 
   + SYN_SENT：在服务端监听后，客户端 socket 执行 CONNECT 连接时，客户端发送 SYN 报文，此   时客户端就进入 SYN_SENT 状态，等待服务端确认。
   + 
   + SYN_RCVD：表示服务端接收到了 SYN 报文。
   + 
   + ESTABLISHED：表示连接已经建立了。
   + 
   + FIN_WAIT_1：其中一方请求终止连接，等待对方的 FIN 报文。
   + 
   + FIN_WAIT_2：在 FIN_WAIT_2 之后， 当对方回应 ACK 报文之后，进入该状态。
   + 
   + TIME_WAIT：表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 之后即可回到CLOSED 状态。
   + 
   + CLOSING：一种罕见状态，发生在发送 FIN 报文之后，本应是先收到 ACK 报文，却先收到对方的 FIN 报文，那么就从 FIN_WAIT_1 的状态进入 CLOSING 状态。
   + 
   + CLOSE_WAIT：表示等待关闭，在 ESTABLISHED 过渡到 LAST_ACK 的一个过渡阶段，该阶段需要考虑是否还有数据发送给对方，如果没有，就可以关闭连接，发送 FIN 报文，然后进入LAST_ACK 状态。
   + 
   + LAST_ACK：被动关闭一方发送 FIN 报文之后，最后等待对方的 ACK 报文所处的状态。
   + 
   + CLOSED：当收到 ACK 保温后，就可以进入 CLOSED 状态了。 
 + 可靠性交付的实现
   + 滑动窗口
     + 发送窗口
     + 大小取决于接收窗口给的值
     + 状态
       + 已发送，接收到返回的ACK
       + 已发送，未接收到返回的ACK
       + 未发送，接收端允许发送
       + 未发送，接收端不允许发送
     + 接收窗口 
       + 大小取决于应用系统和硬件的限制
     + 三种状态
      + 已接收，确认接收
      + 未接收，打算接收
      + 未接收，不打算接受     
   + 超时重传
     + 传输数据包中途丢失
     + 传回的ACK数据包丢失
     + 客户端丢弃该数据包或对方异常未响应 
      + RTO
        + 设定超时时间 
        + 时间过长 传输效率低，性能差
        + 时间过短 导致更多的超时重传，造成阻塞
      + RTT
        + 连接往返时间
        + 发送端发送数据到收到ACK包的时间段
      + 自适应重传算法   
   + 流量控制
     + 控制传输方传输速率，减少网络拥堵
   + 阻塞控制
      + 慢开始
      + 快重传
      + 阻塞避免
      + 快恢复
+ 网络编程接口
  + 一切皆SOCKET
    + 沿用linux的一切皆文件模式 open->read/write->close
    + 常用api
      + socket()
      + bind()
      + listen()
      + connect()
      + open()
      + close()
      + read()
      + write()
      + accept()
    + socket 交互流程
      + 服务器根据地址类型，socket类型，以及协议创建socket
      + 服务器为socket分配端口号，绑定ip
      + 服务器监听端口号，准备接收客户端请求
      + 客户端创建socket
      + 客户端 根据端口号，ip等信息发送请求，试图连接socket
      + 服务端接收到socket请求，被动打开，开始接收请求，此时socket进入阻塞状态，直到返回确认请求，是由于accept方法直到返回链接信息才会返回，然后开始下一个客户端的连接请求
      + 客户端连接成功，开始接收下一个请求
      + 服务器accept方法返回成功，向服务器发送链接状态信息
      + 服务器和客户端通过网络io函数进行传输
      + 客户端关闭socket
      + 服务端关闭socket
 + UDP
   + udp单个数据包，不需要建立链接，简单，不可靠，一丢包，乱序
   + tcp 流式，需要建立链接，可靠，复杂，有序
   + 伪首部
     + 源地址
     + 目的地址
     + 字段全零
     + ip首部协议字段值 udp=18       
     + udp用户数据长度
   + 校验
     + 首部设置全零
     + 伪首部以及数据段看成许多16位的字符串链接起来
     + 若数据字段不是偶数个，添加一1个16位零 字段
     + 每行进行二进制反码运算
     + 运算和取反得校验和，有差错丢弃该字段
     + 
+ http 的进化
  + 0.9 单行协议
    + 简单，对telenet友好
    + 一种请求方式get 仅超文本
    + 响应后马上结束 了，没有head,没有url,没有status,err,版本控制
  + 1.0  构建可扩展性
    + 三种方式;get head post
    + 有status-code content-Type
    + 对浏览器友好
    + 响应后马上结束链接
    + 不限超文本，可接受其他类型文件，脚本，样式媒体
  + 问题
    + 没发送一次请求就要重新建立一次链接，影响性能
  + 1.1
    + TCP 三次握手会在任何连接被建立之前发生一次。最终，当发送了所有数据之后，服务器发送一个消息，表示不会再有更多数据向客户端发送了；则客户端才会关闭连接（断开 TCP）。HTTP/1.0 存在的问题是，对于每个 请求/响应 轮回，也要建立并关闭一个连接。而改用 HTTP/1.1 后的优点则在于，可以复用同一个连接，来完成多次 请求/响应 轮回
  + Upgrade  
    + 增强型头部
  + https 
    + ssl : 安全套接字层，定义了客户端和服务器之间的安全通信
    + tls  ：安全传输层协议 
+ 物理层
  + 物理层尽可能屏蔽传输媒体和通信手段的影响，消除在数据链路层传输的差异
    + 单向通信
    + 半双工通信
    + 双工通信
    带通调制
      + 讲数字信号（离散信号）转为模拟信号（连续信号）
  + 数据链路层 ：网络层针对的还是主机数据传输，而主机之间有可以有很多链路，数据链路协议就是处理同一链路上的主句
  + 网络层 ：针对主机传输数据，讲数据封装成组，进行传输
  + 运输层 ： 为进程提供数据服务
  + 应用层 ： 为特定应用程序提供数据服务 http dns 数据单位为报文
+ 会话层：建立会话管理
+ 表示层：数据压缩，格式描述，是的数据传输不再来考虑格式问题

+ 应用层
  + 
